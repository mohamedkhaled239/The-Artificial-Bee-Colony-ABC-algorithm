# -*- coding: utf-8 -*-
"""Untitled14.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H3BJEKlt_XjOijMm58EK63Z1wjD0hxN6
"""

import random
import numpy as np

class ABC_TSP:
    def __init__(self, num_employed, num_onlookers, num_iterations, coordinates):
        self.num_employed = num_employed
        self.num_onlookers = num_onlookers
        self.num_iterations = num_iterations
        self.coordinates = coordinates
        self.num_cities = len(coordinates)
        self.dist_matrix = self.calculate_distance_matrix()

    def calculate_distance_matrix(self):
        dist_matrix = np.zeros((self.num_cities, self.num_cities))
        for i in range(self.num_cities):
            for j in range(i + 1, self.num_cities):
                x1, y1 = self.coordinates[i]
                x2, y2 = self.coordinates[j]
                distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
                dist_matrix[i][j] = dist_matrix[j][i] = distance
        return dist_matrix

    def calculate_tour_length(self, tour):
        tour_length = 0
        for i in range(self.num_cities - 1):
            city1 = tour[i]
            city2 = tour[i + 1]
            tour_length += self.dist_matrix[city1][city2]
        return tour_length

    def initialize_employed_bees(self):
        employed_bees = []
        for _ in range(self.num_employed):
            tour = list(range(self.num_cities))
            random.shuffle(tour)
            employed_bees.append(tour)
        return employed_bees

    def employed_bee_phase(self, employed_bees):
        new_employed_bees = []
        for bee in employed_bees:
            neighbor = bee.copy()
            i, j = random.sample(range(self.num_cities), 2)
            neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
            if self.calculate_tour_length(neighbor) < self.calculate_tour_length(bee):
                new_employed_bees.append(neighbor)
            else:
                new_employed_bees.append(bee)
        return new_employed_bees

    def calculate_probabilities(self, employed_bees):
        tour_lengths = [self.calculate_tour_length(bee) for bee in employed_bees]
        total_length = sum(tour_lengths)
        probabilities = [length / total_length for length in tour_lengths]
        return probabilities

    def select_best_tour(self, employed_bees):
        tour_lengths = [self.calculate_tour_length(bee) for bee in employed_bees]
        best_index = np.argmin(tour_lengths)
        return employed_bees[best_index]

    def onlooker_bee_phase(self, employed_bees):
        probabilities = self.calculate_probabilities(employed_bees)
        onlooker_bees = []
        for _ in range(self.num_onlookers):
            bee_index = np.random.choice(range(self.num_employed), p=probabilities)
            bee = employed_bees[bee_index]
            neighbor = bee.copy()
            i, j = random.sample(range(self.num_cities), 2)
            neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
            onlooker_bees.append(neighbor)
        return onlooker_bees

    def scout_bee_phase(self, employed_bees):
        best_bee = self.select_best_tour(employed_bees)
        new_employed_bees = []
        for bee in employed_bees:
            if bee == best_bee or random.uniform(0, 1) < 0.1:
                tour = list(range(self.num_cities))
                random.shuffle(tour)
                new_employed_bees.append(tour)
            else:
                new_employed_bees.append(bee)
        return new_employed_bees

    def run(self):
        employed_bees = self.initialize_employed_bees()
        best_tour = self.select_best_tour(employed_bees)
        best_length = self.calculate_tour_length(best_tour)

        for _ in range(self.num_iterations):
            employed_bees = self.employed_bee_phase(employed_bees)
            onlooker_bees = self.onlooker_bee_phase(employed_bees)
            employed_bees = self.scout_bee_phase(onlooker_bees)

            current_best = self.select_best_tour(employed_bees)
            current_length = self.calculate_tour_length(current_best)
            if current_length < best_length:
                best_tour = current_best
                best_length = current_length

        return best_tour, best_length


# Example usage
coordinates = [(0, 0), (0, 4), (2, 3), (1, 4), (4, 6)]
abc_tsp = ABC_TSP(num_employed=50, num_onlookers=50, num_iterations=100, coordinates=coordinates)
best_tour, best_length = abc_tsp.run()

print("Best Path:", best_tour)
print("Best  length:", best_length)